# 记录我实现WebServer
reactor/procatar模式均有。
## reactor 模式如下实现：
* 主线程：
    1. 监听和建立客户端的连接；
    2. 接收客户端的请求，创建一个任务，并把该任务放入任务队列；
    3. 通知分发线程。
* 分发线程
    1. 查看任务队列，看是否有请求任务？没有任务则继续睡觉，否则把任务取出来，然后分发给线程池；
    2. 线程池有空闲的线程，则把该任务交给空闲的线程处理，否则等待。
* 工作线程
    1. 执行任务
    2. 销毁任务

1、主线程往epoll 内核事件表中注册socket上的读就绪事件。

2、主线程调用epoll_wait等待socket上有数据可读。

3、当socket 上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。

4、睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket 上的写就绪事件。

5、主线程调用epoll_wait等待socket可写。

6、当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。

7、睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。

## procator
使用异步I/O模型（以aio_read和 aio_write为例）实现的Proactor模式的工作流程是:
1、主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序（这里以信号为例，详情请参考sigevent的man手册)。

2、主线程继续处理其他逻辑。

3、当socket 上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。

4、应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket 上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序（仍然以信号为例)。

5、主线程继续处理其他逻辑。

6、当用户缓冲区的数据被写人socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。

7、应用程序预先定义好的信号处理函数选择一-个工作线程来做善后处理，比如决定是否关闭socket。


procatar 模式可以使用reactor模式模拟的：

1、主线程往epoll内核事件表中注册socket 上的读就绪事件。

2、主线程调用epoll_wait等待socket上有数据可读。

3、当socket 上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插人请求队列。

4、睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll 内核事件表中注册socket上的写就绪事件

5、主线程调用epoll_wait等待socket可写。

6）当socket可写时，epoll_wait通知主线程。主线程往socket上写人服务器处理客户请求的结果。


总的来说：
* reactor模式中，主线程(I/O处理单元)只负责监听文件描述符上是否有事件发生，有的话立即通知工作线程(逻辑单元)，读写数据、接受新连接及处理客户请求均在工作线程中完成。通常由同步I/O实现。
* proactor模式中，主线程和内核负责处理读写数据、接受新连接等I/O操作，工作线程仅负责业务逻辑，如处理客户请求。通常由异步I/O实现。


WebServer主要有


## log
使用单例模式



## 调试
我是在ubuntu上用vscode进行开发的，在调试过程中发现了一些问题。可以在命令行中使用以下代码开启管理员模式进而调试。
* OS VERSION : Ubuntu 20.04.2 LTS
* VScode Version : 1.73.1
```
sudo code --no-sandbox --disable-gpu-sandbox --user-data-dir=/root/.vscode/
```

